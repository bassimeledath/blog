{
  "hash": "a432d769587266949056e82ad8f7e548",
  "result": {
    "markdown": "---\ntitle: 'Beyond the Basics: Patterns for Aspiring Python Developers'\ndate: today\ncategories: ['Python', 'Programming Patterns']\ndescription: 'Learn about data classes, abstract methods, decorators, and much more'\nexecute: \n  echo: true\n  message: false\n  warning: false\neditor_options: \n  chunk_output_type: console\n---\n\n![](assets/main.png)\n\n### Python Data Structures and Types\n\n#### Data Classes\nClasses in python can get quite chaotic and verbose. This is especially annoying when you're using a class to simply store data. \n\n`Data classes` in Python are a way to make these types of classes - ones primarily used to store data - more concise and readable. They reduce a ton of boilerplate code while making your classes clean and manageable. \n\nLet's say your ice cream store has a class to represent an ice cream flavor. If you didn't use a data class your code would look something like this:\n\n::: {.cell execution_count=1}\n``` {.python .cell-code}\nclass IceCream:\n    def __init__(self, flavor, price, stock):\n        self.flavor = flavor\n        self.price = price\n        self.stock = stock\n\n    def __repr__(self):\n        return f\"IceCream(flavor={self.flavor}, price={self.price}, stock={self.stock})\"\n\n    def __eq__(self, other):\n        \"\"\"Check if two ice cream flavors are the same.\"\"\"\n        return (\n            self.flavor == other.flavor\n            and self.price == other.price\n            and self.stock == other.stock\n        )\n```\n:::\n\n\nBut if you used a data class, you could reduce all of that to just this:\n\n::: {.cell execution_count=2}\n``` {.python .cell-code}\nfrom dataclasses import dataclass\n\n@dataclass\nclass IceCream:\n    flavor: str\n    price: float\n    stock: int\n\n# Usage\nvanilla = IceCream(flavor=\"Vanilla\", price=1.99, stock=20)\nchocolate = IceCream(flavor=\"Chocolate\", price=2.49, stock=15)\n\n# Here we can call the __repr__() method even though we didn't explicitly define it\nprint(vanilla)\nprint(chocolate)\n\n# Here we can call the __eq__() method even though we didn't explicitly define it\nprint(vanilla == chocolate)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nIceCream(flavor='Vanilla', price=1.99, stock=20)\nIceCream(flavor='Chocolate', price=2.49, stock=15)\nFalse\n```\n:::\n:::\n\n\nA lot more concise. When you use the dataclasses.dataclass decorator in Python, it automatically adds several special methods to your class, based on the fields you define. These include the __init__(), __repr__(), and __eq__() methods, among others. \n\nThe dataclass decorator also has several optional parameters that you can use to customize the behavior of your data class. For example, you can use the `froze`n parameter to make your data class immutable, which is useful for preventing accidental changes to your data. You can also add an `order` parameter to make your data class sortable.\n\n::: {.cell execution_count=3}\n``` {.python .cell-code}\nfrom dataclasses import dataclass\nfrom pprint import pprint\nimport inspect\n\n@dataclass(frozen=True, order=True)\nclass IceCream:\n    flavor: str\n    price: float\n    stock: int\n\npprint(inspect.getmembers(IceCream, inspect.isfunction))\n\n# Sort a list of IceCream objects by price\nice_creams = [\n    IceCream(flavor=\"Vanilla\", price=1.99, stock=20),\n    IceCream(flavor=\"Chocolate\", price=2.49, stock=15),\n    IceCream(flavor=\"Strawberry\", price=2.99, stock=10),\n]\nsorted_ice_creams = sorted(ice_creams, key=lambda item: item.price)\nprint(f\"Sorted Ice Creams: {sorted_ice_creams}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[('__delattr__', <function IceCream.__delattr__ at 0x1312860e0>),\n ('__eq__', <function IceCream.__eq__ at 0x131285d80>),\n ('__ge__', <function IceCream.__ge__ at 0x131286050>),\n ('__gt__', <function IceCream.__gt__ at 0x131285fc0>),\n ('__hash__', <function IceCream.__hash__ at 0x131286170>),\n ('__init__', <function IceCream.__init__ at 0x131285360>),\n ('__le__', <function IceCream.__le__ at 0x131285f30>),\n ('__lt__', <function IceCream.__lt__ at 0x131285ea0>),\n ('__repr__', <function IceCream.__repr__ at 0x131285480>),\n ('__setattr__', <function IceCream.__setattr__ at 0x131285cf0>)]\nSorted Ice Creams: [IceCream(flavor='Vanilla', price=1.99, stock=20), IceCream(flavor='Chocolate', price=2.49, stock=15), IceCream(flavor='Strawberry', price=2.99, stock=10)]\n```\n:::\n:::\n\n\nAs you can see, enabling the `order` parameter adds a `__lt__()` method to your class, which allows you to sort your data class objects.\n\nIn the machine learning verse, you can use data classes for storing model hyperparameters, for example:\n\n::: {.cell execution_count=4}\n``` {.python .cell-code}\nfrom dataclasses import dataclass\n\n@dataclass\nclass HyperParams:\n    learning_rate: float\n    num_epochs: int\n    batch_size: int\n    optimizer: str = \"adam\"\n\n    def display(self):\n        \"\"\"Prints a formatted view of the configuration.\"\"\"\n        print(f\"Model Hyperparameters:\\n{'-'*10}\")\n        for key, value in self.__dict__.items():\n            print(f\"{key}: {value}\")\n\n# Usage\nhyper_params = HyperParams(learning_rate=0.001, num_epochs=10, batch_size=32)\nhyper_params.display()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nModel Hyperparameters:\n----------\nlearning_rate: 0.001\nnum_epochs: 10\nbatch_size: 32\noptimizer: adam\n```\n:::\n:::\n\n\nNote, while these methods are provided automatically, you can still define your own implementations of these methods in your class, which will override the automatically generated ones.\n\n#### Abstract Base Classes \nAbstract Base Classes (ABCs) in Python are a way to define a set of methods that must be created within any child classes built from the abstract class. \n\nWhat does that really mean? Let's say you have a class that represents an ice cream maker. You want to make sure that any ice cream maker you create has a `make_ice_cream()` method. You can use an abstract base class to *enforce* this.\n\n**Ice Cream Machine Example:**\n\n::: {.cell execution_count=5}\n``` {.python .cell-code}\nfrom abc import ABC, abstractmethod\n\nclass IceCreamMaker(ABC):\n    @abstractmethod\n    def make_ice_cream(self, flavor: str) -> None:\n        pass\n\nclass SimpleIceCreamMaker(IceCreamMaker):\n    # We must implement the make_ice_cream() method here or we'll get an error\n    def make_ice_cream(self, flavor: str) -> None:\n        print(f\"Making {flavor} ice cream!\")\n\n# Usage\nmachine = SimpleIceCreamMaker()\nmachine.make_ice_cream(\"Chocolate\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMaking Chocolate ice cream!\n```\n:::\n:::\n\n\nAbstract classes and methods can be useful in so many situations. Let's say you're building a machine learning library involving many types of models. You can use an abstract base class to define methods like `fit()` and `predict()` that must be implemented by any model you create.\n\n\n----\n\nClass Special Methods\nSpecial methods in Python are a set of predefined methods you can use to enrich your classes. They are easy to recognize because they start and end with double underscores (__). Special methods allow us to emulate the behavior of built-in types.\n\nIce Cream Flavor Example:\n\n::: {.cell execution_count=6}\n``` {.python .cell-code}\nclass IceCream:\n    def __init__(self, flavor, stock):\n        self.flavor = flavor\n        self.stock = stock\n\n    def __str__(self):\n        \"\"\"Returns a string representation of the object.\"\"\"\n        return f\"{self.flavor} Ice Cream\"\n\n    def __eq__(self, other):\n        \"\"\"Check if two ice cream flavors are the same.\"\"\"\n        return self.flavor == other.flavor\n\n# Usage\nvanilla = IceCream(\"Vanilla\", 20)\nchocolate = IceCream(\"Chocolate\", 15)\nprint(vanilla)  # Output: Vanilla Ice Cream\nprint(vanilla == chocolate)  # Output: False\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVanilla Ice Cream\nFalse\n```\n:::\n:::\n\n\n## Inheritance\n\nInheritance allows new objects to take on the properties of existing objects. It's a way to form new classes using classes that have already been defined.\n\nIce Cream and Sorbet Example:\n\n::: {.cell execution_count=7}\n``` {.python .cell-code}\nclass IceCream:\n    def __init__(self, flavor):\n        self.flavor = flavor\n\nclass Sorbet(IceCream):  # Sorbet is a type of Ice Cream\n    def __init__(self, flavor, fruit_content):\n        super().__init__(flavor)\n        self.fruit_content = fruit_content\n\n# Usage\nlemon_sorbet = Sorbet(\"Lemon\", 30)\nprint(lemon_sorbet.flavor) \n```\n\n::: {.cell-output .cell-output-stdout}\n```\nLemon\n```\n:::\n:::\n\n\nDecorators in Depth\nDecorators are a significant part of Python. In simple words, decorators modify the behavior of function or class. In terms of the ice cream store, think of a decorator as an additional topping or feature to your basic ice cream functionality.\n\nStatic Method and Property Example:\n\n::: {.cell execution_count=8}\n``` {.python .cell-code}\nclass IceCreamShop:\n    _sales_tax = 0.05  # 5% Sales Tax\n\n    @staticmethod\n    def compute_tax(amount):\n        return amount * IceCreamShop._sales_tax\n\n    @property\n    def sales_tax(self):\n        return self._sales_tax\n\n# Usage\nprint(IceCreamShop.compute_tax(100))  # Output: 5.0\nshop = IceCreamShop()\nprint(shop.sales_tax)  # Output: 0.05\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n5.0\n0.05\n```\n:::\n:::\n\n\nIn this section, we looked at how Python's object-oriented programming features can be used to model real-world scenarios such as managing an ice cream store. Special methods allow us to integrate with Python's built-in features and make our classes more intuitive. Inheritance lets us reuse and extend existing code, and decorators provide a flexible way to add or modify behavior without changing the existing code structure. All of these features are essential tools in a Python programmer's toolkit.\n\nMixins: Leveraging for Composition Over Inheritance\nMixins are a sort of class that is used to \"mix in\" extra properties and methods into a class. This allows for an organized way of using composition to add features to classes in a modular and maintainable way. Unlike traditional inheritance, mixins don't represent a \"is-a\" relationship but rather a \"has-a\" relationship.\n\nIce Cream Mixin Example:\n\n::: {.cell execution_count=9}\n``` {.python .cell-code}\nclass FlavorMixin:\n    def add_flavor(self, flavor):\n        self.flavor = flavor\n        print(f\"Flavor {flavor} added!\")\n\nclass ToppingMixin:\n    def add_topping(self, topping):\n        self.topping = topping\n        print(f\"Topping {topping} added!\")\n\n# Base class\nclass BasicIceCream:\n    pass\n\n# Enhanced class with mixins\nclass DeluxeIceCream(FlavorMixin, ToppingMixin, BasicIceCream):\n    pass\n\n# Usage\ndeluxe = DeluxeIceCream()\ndeluxe.add_flavor(\"Chocolate\")\ndeluxe.add_topping(\"Sprinkles\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFlavor Chocolate added!\nTopping Sprinkles added!\n```\n:::\n:::\n\n\nMeta-Classes: Understanding Dynamic Class Creation\nMetaclasses are the 'classes of classes' in Python. They define the behavior of a class and its instances. They are an advanced feature that allows you to control the creation of classes and can be used to provide elegant solutions to complex problems.\n\nIce Cream Meta-Class Example:\n\n::: {.cell execution_count=10}\n``` {.python .cell-code}\nclass MetaIceCream(type):\n    def __new__(cls, name, bases, dct):\n        dct['favorite_flavor'] = \"vanilla\"  # let's say vanilla is the favorite flavor by default\n        return super().__new__(cls, name, bases, dct)\n\nclass IceCream(metaclass=MetaIceCream):\n    def __init__(self, flavor):\n        self.flavor = flavor\n\n# Usage\nic = IceCream(\"strawberry\")\nprint(ic.favorite_flavor)  # Even though it's not defined explicitly, it's vanilla\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nvanilla\n```\n:::\n:::\n\n\nPrivate and Protected Members: Conventions and Enforcement\nIn Python, there is a convention for indicating that a variable is intended to be private or protected using underscores. A single underscore _ before a variable name is conventionally used for protected members, and a double underscore __ for private members. This doesn't enforce strict privacy or protection but is a strong indication to other programmers, and also influences name mangling to avoid naming conflicts in subclasses.\n\nPrivate and Protected Members Example:\n\n::: {.cell execution_count=11}\n``` {.python .cell-code}\nclass IceCreamMachine:\n    def __init__(self, model):\n        self._operating_temp = -10  # Protected Member\n        self.__model = model  # Private Member\n\n    def dispense(self):\n        print(f\"Dispensing at {self._operating_temp} degrees from {self.__model}.\")\n\n# Usage\nmachine = IceCreamMachine(\"Frosty 5000\")\nmachine.dispense()\nprint(machine._operating_temp)  # This is accessible but shouldn't be altered directly\n# print(machine.__model)  # This will give an error as it's a private member\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDispensing at -10 degrees from Frosty 5000.\n-10\n```\n:::\n:::\n\n\nIn this section, we delved deeper into the object-oriented features of Python by exploring mixins for composition, metaclasses for dynamic class creation, and the conventions around private and protected members. Each of these topics presents sophisticated ways to structure your Python code for maximum readability, maintainability, and functionality, especially in complex applications like managing an ice cream store's operations.\n------\n\nPython Function Essentials\nFunction Signatures: Crafting Readable and Maintainable Interfaces\nFunction signatures are the part of the function that defines its input and output. A clear and concise function signature can significantly improve the readability and maintainability of your code. Python's type hinting and default values are some tools you can use to create such signatures.\n\nIce Cream Order Function Example:\n\n::: {.cell execution_count=12}\n``` {.python .cell-code}\nfrom typing import List\n\ndef place_order(flavor: str, scoops: int = 1, toppings: List[str] = None) -> None:\n    toppings_list = toppings if toppings else [\"No toppings\"]\n    print(f\"Order: {scoops} scoop(s) of {flavor} ice cream with {' and '.join(toppings_list)}.\")\n\nplace_order(\"Vanilla\", 2, [\"Cherry\", \"Sprinkles\"])\nplace_order(\"Chocolate\") # Uses default scoops and toppings\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOrder: 2 scoop(s) of Vanilla ice cream with Cherry and Sprinkles.\nOrder: 1 scoop(s) of Chocolate ice cream with No toppings.\n```\n:::\n:::\n\n\nArguments: Understanding *args and **kwargs\n*args and **kwargs allow you to pass a variable number of arguments to a function, which can be very helpful when you don't know beforehand how many arguments you will need. *args is used to send a non-keyworded variable-length argument list, and **kwargs allows you to pass keyworded variable length of arguments.\n\nCustom Ice Cream Mix Function Example:\n\n::: {.cell execution_count=13}\n``` {.python .cell-code}\ndef mix_ice_cream(*flavors, **toppings):\n    print(f\"Mixing {' and '.join(flavors)}.\")\n    if toppings:\n        print(\"Adding toppings:\")\n        for topping, quantity in toppings.items():\n            print(f\"- {quantity}x {topping}\")\n\nmix_ice_cream(\"Vanilla\", \"Strawberry\", Sprinkles=10, Nuts=5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMixing Vanilla and Strawberry.\nAdding toppings:\n- 10x Sprinkles\n- 5x Nuts\n```\n:::\n:::\n\n\nAbstract Base Classes and Protocols\nAbstract Base Classes (ABCs) and protocols are used to define a set of methods that must be created within any child classes built from the abstract class or implementing the protocol. They are a form of interface checking more strict than duck-typing and allow for a cleaner architecture.\n\nIce Cream Machine Interface Example:\n\n::: {.cell execution_count=14}\n``` {.python .cell-code}\nfrom abc import ABC, abstractmethod\n\nclass IceCreamMachine(ABC):\n    @abstractmethod\n    def make_ice_cream(self, flavor: str) -> None:\n        pass\n\nclass SoftServeMachine(IceCreamMachine):\n    def make_ice_cream(self, flavor: str) -> None:\n        print(f\"Dispensing soft serve {flavor} ice cream.\")\n\nmachine = SoftServeMachine()\nmachine.make_ice_cream(\"Mango\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nDispensing soft serve Mango ice cream.\n```\n:::\n:::\n\n\nIn this section, we explored how to define clear and effective functions in Python. By designing intuitive function signatures, utilizing variable arguments, and adhering to the principles of abstract base classes and protocols, you can write code that is both flexible and easy to understand. These practices are crucial for creating a robust and maintainable codebase, especially in complex applications such as those for managing an ice cream store.\n\nUsage of collections.abc like Iterable\nThe collections.abc module provides a set of abstract base classes that can be used to test whether a class provides a particular interface, for example, whether it is iterable. This can be particularly useful when you want to enforce that an object adheres to a certain protocol or interface.\n\nIce Cream Batch Iterable Example:\n\n::: {.cell execution_count=15}\n``` {.python .cell-code}\nfrom collections.abc import Iterable\n\nclass IceCreamBatch:\n    def __init__(self, flavors):\n        self.flavors = flavors\n\n    def __iter__(self):\n        return iter(self.flavors)\n\nbatch = IceCreamBatch([\"Vanilla\", \"Chocolate\", \"Strawberry\"])\nfor flavor in batch:\n    print(f\"Flavor: {flavor}\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nFlavor: Vanilla\nFlavor: Chocolate\nFlavor: Strawberry\n```\n:::\n:::\n\n\nDefining Custom Abstract Methods\nCustom abstract methods can be defined in your classes to enforce that certain methods are implemented in subclasses, providing a clear contract for subclass implementation.\n\nCustom Ice Cream Maker Example:\n\n::: {.cell execution_count=16}\n``` {.python .cell-code}\nfrom abc import ABC, abstractmethod\n\nclass CustomIceCreamMaker(ABC):\n    @abstractmethod\n    def make_ice_cream(self, flavor: str, toppings: list):\n        pass\n\nclass GourmetIceCreamMaker(CustomIceCreamMaker):\n    def make_ice_cream(self, flavor: str, toppings: list):\n        print(f\"Creating gourmet {flavor} ice cream with {', '.join(toppings)}.\")\n\ngourmet_maker = GourmetIceCreamMaker()\ngourmet_maker.make_ice_cream(\"Mint Chocolate\", [\"Chocolate Chips\", \"Mint Leaves\"])\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nCreating gourmet Mint Chocolate ice cream with Chocolate Chips, Mint Leaves.\n```\n:::\n:::\n\n\nLambda Functions: When and How to Use Them Effectively\nLambda functions are small anonymous functions that are defined with the lambda keyword. They can have any number of arguments but only one expression. They are handy for creating quick functions that aren't complex.\n\nFavorite Flavor Filter Example:\n\n::: {.cell execution_count=17}\n``` {.python .cell-code}\nflavors = [\"Vanilla\", \"Chocolate\", \"Strawberry\", \"Mint\"]\n\n# Filter flavors list to only include flavors that contain the letter 'n'\nfiltered_flavors = list(filter(lambda flavor: 'n' in flavor, flavors))\nprint(filtered_flavors)  # Output: ['Vanilla', 'Mint']\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n['Vanilla', 'Mint']\n```\n:::\n:::\n\n\nClosures and Factory Functions: Encapsulating State and Behavior\nClosures are a way of keeping alive a function with its environment. A closure is a record storing a function together with an environment: a mapping associating each free variable of the function with the value or storage location to which the name was bound when the closure was created.\n\nIce Cream Customizer Factory Example:\n\n::: {.cell execution_count=18}\n``` {.python .cell-code}\ndef ice_cream_customizer(topping):\n    def add_topping(flavor):\n        return f\"{flavor} ice cream with {topping}\"\n    return add_topping\n\nadd_chocolate_syrup = ice_cream_customizer(\"Chocolate Syrup\")\nprint(add_chocolate_syrup(\"Vanilla\")) # Output: Vanilla ice cream with Chocolate Syrup\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVanilla ice cream with Chocolate Syrup\n```\n:::\n:::\n\n\nIn this expanded section, we dove deeper into abstract base classes with collections.abc and defining custom abstract methods, giving you the tools to enforce class interfaces in a structured way. We also explored lambda functions for quick, one-off functional operations and closures for maintaining state in your functions, all of which enhance the flexibility and expressiveness of your Python code in managing an ice cream store's operations.\n\n-----\n\nHere's the content for Section 4: Error Handling and Logging, formatted for easy copy-pasting into your .qmd file:\n\nError Handling and Logging\nRaising Exceptions: Structured Way of Using raise\nIn Python, exceptions are raised whenever a program encounters an error. The raise statement allows you to force a specified exception to occur. Properly handling these exceptions is crucial for maintaining the reliability and robustness of your applications.\n\nIce Cream Flavor Availability Check Example:\n\n::: {.cell execution_count=19}\n``` {.python .cell-code}\ndef check_flavor_availability(flavor, available_flavors):\n    if flavor not in available_flavors:\n        raise ValueError(f\"{flavor} is not available.\")\n    print(f\"{flavor} is available!\")\n\ntry:\n    check_flavor_availability(\"Pistachio\", [\"Vanilla\", \"Chocolate\", \"Strawberry\"])\nexcept ValueError as e:\n    print(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPistachio is not available.\n```\n:::\n:::\n\n\nCommon Exception Types: TypeError, AssertionError, NotImplementedError, etc.\nPython comes with a variety of built-in exceptions, which are classes that can be used to communicate what type of error occurred. Understanding these can help you better diagnose problems and inform users more effectively.\n\nIce Cream Serving Size Example:\n\n::: {.cell execution_count=20}\n``` {.python .cell-code}\ndef serve_ice_cream(scoops):\n    if not isinstance(scoops, int):\n        raise TypeError(\"Scoops must be an integer.\")\n    if scoops <= 0:\n        raise ValueError(\"Scoops must be a positive number.\")\n    if scoops > 3:\n        raise AssertionError(\"Too many scoops requested!\")\n    print(f\"Serving {scoops} scoops of ice cream!\")\n\ntry:\n    serve_ice_cream(4)\nexcept (TypeError, ValueError, AssertionError) as e:\n    print(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nToo many scoops requested!\n```\n:::\n:::\n\n\nIn this section, we explored the structured way of raising exceptions in Python and handling common exception types. Through effective error handling and understanding of Python's exception hierarchy, you can make your ice cream store application more reliable and user-friendly, avoiding unexpected crashes and providing clear feedback for troubleshooting.\n\nLogging: Leveraging Python's Logging Module for Scalable Applications\nPython's built-in logging module allows you to track events when your application runs, providing a flexible way to output informational and error messages. Logging is essential for debugging and understanding the behavior of an application, especially as it grows in complexity.\n\nIce Cream Store Logging Example:\n\n::: {.cell execution_count=21}\n``` {.python .cell-code}\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\ndef restock_ice_cream(flavor, quantity):\n    logging.info(f\"Restocking {flavor}: {quantity} units.\")\n    # Restocking logic here\n    if quantity < 0:\n        logging.error(\"Quantity cannot be negative!\")\n\nrestock_ice_cream(\"Vanilla\", 20)\nrestock_ice_cream(\"Chocolate\", -5) # Triggers error log\n```\n:::\n\n\nCustom Exceptions: Designing for Clarity and Control\nCustom exceptions allow you to create your own exception types, making your code's error messages more informative and easier to understand. This can be particularly helpful in debugging or when other developers are using your code.\n\nCustom InsufficientStockException Example:\n\n::: {.cell execution_count=22}\n``` {.python .cell-code}\nclass InsufficientStockException(Exception):\n    def __init__(self, flavor, requested, available):\n        message = f\"{flavor} stock insufficient. Requested: {requested}, Available: {available}\"\n        super().__init__(message)\n\ndef sell_ice_cream(flavor, quantity, stock):\n    if stock[flavor] < quantity:\n        raise InsufficientStockException(flavor, quantity, stock[flavor])\n    stock[flavor] -= quantity\n    print(f\"Selling {quantity} {flavor} ice creams!\")\n\nstock = {\"Vanilla\": 10, \"Chocolate\": 5}\ntry:\n    sell_ice_cream(\"Vanilla\", 15, stock)\nexcept InsufficientStockException as e:\n    print(e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVanilla stock insufficient. Requested: 15, Available: 10\n```\n:::\n:::\n\n\nContextual Logging: Enhancing Logs with Contextual Information\nContextual logging involves adding additional information to your logs, such as timestamps, function names, or other relevant data. This makes the logs more useful and easier to understand, especially when dealing with complex systems or when you're trying to debug issues post-mortem.\n\nEnhanced Ice Cream Store Logging Example:\n\n::: {.cell execution_count=23}\n``` {.python .cell-code}\nimport logging\n\nlogger = logging.getLogger(\"IceCreamLogger\")\nhandler = logging.StreamHandler()\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nhandler.setFormatter(formatter)\nlogger.addHandler(handler)\nlogger.setLevel(logging.INFO)\n\ndef make_ice_cream(flavor):\n    logger.info(f\"Making {flavor} ice cream.\")\n    # Ice cream making logic here\n    if flavor == \"Mint\":\n        logger.warning(\"Mint is currently low in stock!\")\n\nmake_ice_cream(\"Vanilla\")\nmake_ice_cream(\"Mint\") # Triggers a warning log\n```\n:::\n\n\nIn this expanded section of Error Handling and Logging, we delved into the world of logging, custom exceptions, and contextual logging in Python. By implementing these techniques, you can greatly improve the maintainability, debuggability, and overall quality of your applications, making it easier to manage your ice cream store's operations and quickly respond to issues as they arise.\n\n-----\n\nNaming and Documentation Conventions\nNaming Conventions: Understanding Underscore Prefixes and Dunder Methods\nPython uses underscores as a way of indicating the intended privacy level and role of variables, methods, and functions. Single and double underscores have special meanings, and understanding these conventions can make your code more Pythonic and readable.\n\nUnderscore and Dunder Example in Ice Cream Context:\n\n::: {.cell execution_count=24}\n``` {.python .cell-code}\nclass IceCream:\n    def __init__(self, flavor):\n        self.flavor = flavor  # Public attribute\n        self._temperature = -5  # Protected attribute: intended for internal use\n        self.__secret_recipe = \"Sugar and Spice\"  # Private attribute: name mangling\n\n    def get_secret_recipe(self):\n        return self.__secret_recipe  # Accessing the private attribute internally\n\nice_cream = IceCream(\"Vanilla\")\nprint(ice_cream.flavor)  # Public, so accessible\nprint(ice_cream._temperature)  # Protected, should not be accessed directly\n# Trying to access the private attribute directly will raise an AttributeError due to name mangling\n# Correct way is to use a method that accesses it internally like get_secret_recipe()\ntry:\n    print(ice_cream.__secret_recipe)\nexcept AttributeError as e:\n    print(\"Can't access private attribute:\", e)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nVanilla\n-5\nCan't access private attribute: 'IceCream' object has no attribute '__secret_recipe'\n```\n:::\n:::\n\n\nDocumentation Standards: Best Practices for Writing Python Docstrings\nDocstrings are a way of documenting Python modules, functions, classes, and methods. They're essential for making your code understandable to others and your future self. Well-written docstrings can also facilitate automatic documentation generation.\n\nDocstring Example for Ice Cream Class:\n\n::: {.cell execution_count=25}\n``` {.python .cell-code}\nclass IceCream:\n    \"\"\"\n    A class representing an ice cream with various properties.\n    Attributes:\n        flavor (str): The flavor of the ice cream.\n        scoops (int): The number of scoops.\n    \"\"\"\n\n    def __init__(self, flavor, scoops=1):\n        \"\"\"\n        The constructor for IceCream class.\n\n        Parameters:\n            flavor (str): The flavor of the ice cream.\n            scoops (int): The number of scoops. Default is 1.\n        \"\"\"\n        self.flavor = flavor\n        self.scoops = scoops\n```\n:::\n\n\nPEP 8 and Beyond: Exploring Python Enhancement Proposals Related to Style and Convention\nPEP 8 is the de facto code style guide for Python. It's important to adhere to these guidelines to ensure that your code is clean, readable, and consistent with what the majority of Python developers expect.\n\nIce Cream Store Code Style Example:\n\n::: {.cell execution_count=26}\n``` {.python .cell-code}\ndef restock_ice_cream(flavor, quantity):\n    if quantity > 0:\n        print(f\"Restocking {quantity} units of {flavor} ice cream.\")\n    else:\n        print(\"Cannot restock negative quantity!\")\nrestock_ice_cream(\"Chocolate\", 20)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRestocking 20 units of Chocolate ice cream.\n```\n:::\n:::\n\n\nType Docstrings: Documenting Types and Expected Behaviors\nType docstrings are an extension of regular docstrings that include information about the types of parameters, return values, and exceptions. They can greatly enhance the understandability of your code, especially when used in conjunction with static type checkers.\n\nType Docstring for Ice Cream Factory Function:\n\n::: {.cell execution_count=27}\n``` {.python .cell-code}\ndef create_ice_cream(flavor: str, toppings: list) -> \"IceCream\":\n    \"\"\"\n    Creates an IceCream object with the given flavor and toppings.\n    Parameters:\n        flavor (str): The flavor of the ice cream.\n        toppings (list): A list of toppings to add.\n\n    Returns:\n        IceCream: An IceCream object with specified flavor and toppings.\n\n    Raises:\n        ValueError: If no flavor is provided.\n    \"\"\"\n    if not flavor:\n        raise ValueError(\"Flavor is required!\")\n    return IceCream(flavor, toppings)\n```\n:::\n\n\nIn this section, we explored the essential naming and documentation conventions in Python. By adhering to these conventions and utilizing docstrings effectively, you can make your code much more understandable and maintainable. This is especially crucial in collaborative environments or when your codebase grows in size and complexity. Each of these practices plays a vital role in keeping your ice cream store's codebase healthy and robust.\n\n-----\n\nHere's the content for the first part of Section 6: Performance and Efficiency Patterns, focusing on deep vs shallow copies, and enums and constants, formatted for easy copy-pasting into your .qmd file:\n\nPerformance and Efficiency Patterns\nDeep vs Shallow Copies: Understanding .copy() and Its Implications\nIn Python, copying objects is not always as straightforward as it might seem. A shallow copy creates a new object, but doesn't create copies of the objects found within the original object. In contrast, a deep copy creates a new object and recursively copies all the objects found within the original object. Understanding the difference is crucial for managing memory and avoiding unintended side effects, especially when working with complex, mutable data structures.\n\nShallow vs Deep Copy Example:\n\n::: {.cell execution_count=28}\n``` {.python .cell-code}\nimport copy\n\n# Original list of ice cream flavors\noriginal_flavors = [[\"Vanilla\", \"Chocolate\"], [\"Strawberry\"]]\n\n# Shallow copy: only copies the outer list\nshallow_copied_flavors = copy.copy(original_flavors)\nshallow_copied_flavors[0][0] = \"Mint\"\nprint(original_flavors) # Notice \"Mint\" replaces \"Vanilla\" in the original\n\n# Deep copy: copies all levels\ndeep_copied_flavors = copy.deepcopy(original_flavors)\ndeep_copied_flavors[1][0] = \"Blueberry\"\nprint(original_flavors) # The original remains unchanged\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[['Mint', 'Chocolate'], ['Strawberry']]\n[['Mint', 'Chocolate'], ['Strawberry']]\n```\n:::\n:::\n\n\nEnums and Constants: Utilizing enum for Readable and Efficient Code\nEnums (enumerations) are sets of symbolic names bound to unique, constant values. In Python, enums are implemented using the enum module. Using enums can make your code more readable and maintainable by providing meaningful names to constant values.\n\nIce Cream Flavor Enums Example:\n\n::: {.cell execution_count=29}\n``` {.python .cell-code}\nfrom enum import Enum\n\nclass IceCreamFlavor(Enum):\n    VANILLA = 1\n    CHOCOLATE = 2\n    STRAWBERRY = 3\n    MINT = 4\n\ndef serve(flavor: IceCreamFlavor):\n    if flavor == IceCreamFlavor.MINT:\n        print(\"Serving Mint Flavor!\")\n    else:\n        print(f\"Serving {flavor.name} Flavor!\")\n\n# Usage\nserve(IceCreamFlavor.MINT)  # Outputs: Serving Mint Flavor!\nserve(IceCreamFlavor.VANILLA)  # Outputs: Serving VANILLA Flavor!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nServing Mint Flavor!\nServing VANILLA Flavor!\n```\n:::\n:::\n\n\nIn this section, we covered two important aspects of performance and efficiency patterns in Python: understanding the implications of shallow and deep copies, and utilizing enums for cleaner, more efficient code. These practices can help prevent bugs and improve the performance of your applications, contributing to a well-functioning ice cream store's operations.\n\nUsing auto and unique for Custom Enumerations\nThe auto feature in Python's enum module can automatically assign values to members, making it easier to manage enums. The unique decorator ensures all values are distinct, preventing duplicate values that can lead to bugs.\n\nCustom Ice Cream Size Enumeration Example:\n\n::: {.cell execution_count=30}\n``` {.python .cell-code}\nfrom enum import Enum, auto, unique\n\n@unique\nclass IceCreamSize(Enum):\n    SMALL = auto()\n    MEDIUM = auto()\n    LARGE = auto()\n\ndef order(size: IceCreamSize):\n    print(f\"Ordering a {size.name} ice cream!\")\n\n# Usage\norder(IceCreamSize.SMALL)  # Outputs: Ordering a SMALL ice cream!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nOrdering a SMALL ice cream!\n```\n:::\n:::\n\n\nIterators and Generators: Lazy Evaluation and Efficient Looping\nIterators and generators provide a way to iterate over data more efficiently by lazy evaluating elements, meaning they generate items as needed. This can lead to performance improvements, particularly with large data sets.\n\nDaily Specials Generator Example:\n\n::: {.cell execution_count=31}\n``` {.python .cell-code}\ndef daily_specials(specials):\n    for special in specials:\n        yield f\"Today's special is: {special}\"\n\nspecials_generator = daily_specials([\"Vanilla\", \"Chocolate\", \"Strawberry\"])\nprint(next(specials_generator)) # Outputs: Today's special is: Vanilla\nprint(next(specials_generator)) # Outputs: Today's special is: Chocolate\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nToday's special is: Vanilla\nToday's special is: Chocolate\n```\n:::\n:::\n\n\nPython Caching Techniques: functools.lru_cache and Beyond\nCaching is a technique used to store previous computation results and reuse them when the same inputs occur again, improving the performance of applications. Python provides built-in decorators for caching, like functools.lru_cache, which implements a least recently used cache.\n\nCached Ice Cream Mix Function Example:\n\n::: {.cell execution_count=32}\n``` {.python .cell-code}\nfrom functools import lru_cache\n\n\n@lru_cache(maxsize=32)\ndef mix_ice_cream(flavor1, flavor2):\n    print(f\"Mixing {flavor1} and {flavor2}...\")\n    return f\"{flavor1} and {flavor2} mixed!\"\n\n\nprint(mix_ice_cream(\"Vanilla\", \"Chocolate\"))  # Function is executed\n# Result is cached and returned immediately\n# Result is cached and returned immediately\nprint(mix_ice_cream(\"Vanilla\", \"Chocolate\")) # Result is cached and returned immediately\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMixing Vanilla and Chocolate...\nVanilla and Chocolate mixed!\nVanilla and Chocolate mixed!\n```\n:::\n:::\n\n\nIn this expanded section of Performance and Efficiency Patterns, we explored using auto and unique decorators for defining enums more effectively, leveraging iterators and generators for efficient data handling, and utilizing caching techniques to optimize performance. By incorporating these patterns, you can ensure that your ice cream store's operations run smoothly, even as demand and complexity grow.\n\n-----\n\nAdvanced Python Patterns\nDependency Injection: Techniques for Cleaner Architecture\nDependency Injection (DI) is a design pattern that allows a program to remove hard-coded dependencies and makes it more modular, enabling easier testing and maintenance. In Python, DI can be done in various ways, such as through constructor injection, setter injection, or using a framework.\n\nIce Cream Machine Dependency Injection Example:\n\n::: {.cell execution_count=33}\n``` {.python .cell-code}\nclass IceCreamMaker:\n    def make_ice_cream(self, flavor):\n        print(f\"Making {flavor} ice cream.\")\n\nclass IceCreamStore:\n    def __init__(self, maker: IceCreamMaker):\n        self.maker = maker\n\n    def order_ice_cream(self, flavor):\n        self.maker.make_ice_cream(flavor)\n\nmaker = IceCreamMaker()\nstore = IceCreamStore(maker)\nstore.order_ice_cream(\"Vanilla\")  # Outputs: Making Vanilla ice cream.\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMaking Vanilla ice cream.\n```\n:::\n:::\n\n\nPlugin Architecture: Building Extensible Python Applications\nPlugin architectures allow you to create applications that can be extended through plugins. This pattern is useful for adding features, modifying behaviors, and integrating with other systems without changing the core application code.\n\nIce Cream Flavors Plugin Example:\n\n::: {.cell execution_count=34}\n``` {.python .cell-code}\nclass IceCreamMaker:\n    def __init__(self):\n        self.plugins = {}\n\n    def register_plugin(self, flavor, func):\n        self.plugins[flavor] = func\n\n    def make_ice_cream(self, flavor):\n        if flavor in self.plugins:\n            self.plugins[flavor]()\n        else:\n            print(f\"No plugin for {flavor}!\")\n\nmaker = IceCreamMaker()\n\ndef make_vanilla_ice_cream():\n    print(\"Making Vanilla Ice Cream!\")\n\nmaker.register_plugin(\"Vanilla\", make_vanilla_ice_cream)\nmaker.make_ice_cream(\"Vanilla\")  # Outputs: Making Vanilla Ice Cream!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nMaking Vanilla Ice Cream!\n```\n:::\n:::\n\n\nEvent Driven Programming: Using Callbacks and Hooks\nEvent-driven programming is a paradigm in which the flow of the program is determined by events such as user actions, sensor outputs, or message passing. Python supports event-driven programming by using callbacks and hooks, allowing functions to react to events.\n\nIce Cream Store Event System Example:\n\n::: {.cell execution_count=35}\n``` {.python .cell-code}\nclass EventManager:\n    def __init__(self):\n        self.listeners = {}\n\n    def listen(self, event, function):\n        if event not in self.listeners:\n            self.listeners[event] = []\n        self.listeners[event].append(function)\n\n    def trigger(self, event, data):\n        if event in self.listeners:\n            for function in self.listeners[event]:\n                function(data)\n\nevent_manager = EventManager()\n\ndef on_new_order(order):\n    print(f\"New order for {order} ice cream!\")\n\nevent_manager.listen('new_order', on_new_order)\nevent_manager.trigger('new_order', \"Vanilla\")  # Outputs: New order for Vanilla ice cream!\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nNew order for Vanilla ice cream!\n```\n:::\n:::\n\n\nIn this section on Advanced Python Patterns, we delved into Dependency Injection for cleaner, more modular code architectures, Plugin Architecture for building flexible and extensible applications, and Event-Driven Programming to create responsive and interactive systems. By applying these advanced patterns, your ice cream store application can become more robust, adaptable, and scalable.\n\n-----\n\nHere's the content for Section 8: Concurrency and Parallelism, focusing on threading and multiprocessing, and asyncio, formatted for easy copy-pasting into your .qmd file:\n\nConcurrency and Parallelism\nThreading and Multiprocessing: When and How to Use Them\nPython offers several ways to achieve concurrency and parallelism. Two of the most common are threading and multiprocessing. Threading allows multiple threads to run in the same memory space, while multiprocessing involves running separate memory spaces and is often used to bypass Python's Global Interpreter Lock (GIL).\n\nIce Cream Store Threading Example:\n\n::: {.cell execution_count=36}\n``` {.python .cell-code}\nimport threading\nimport time\n\n\ndef prepare_ice_cream(flavor):\n    print(f\"Preparing {flavor} ice cream...\")\n    time.sleep(2)  # Simulate time-consuming preparation\n    print(f\"{flavor} ice cream is ready!\")\n\n\nthreads = []\nfor flavor in [\"Vanilla\", \"Chocolate\", \"Strawberry\"]:\n    thread = threading.Thread(target=prepare_ice_cream, args=(flavor,))\n    threads.append(thread)\n    thread.start()\n\nfor thread in threads:\n    thread.join()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nPreparing Vanilla ice cream...\nPreparing Chocolate ice cream...\nPreparing Strawberry ice cream...\nVanilla ice cream is ready!Chocolate ice cream is ready!\nStrawberry ice cream is ready!\n\n```\n:::\n:::\n\n\nIce Cream Store Multiprocessing Example:\n```python\n\nimport multiprocessing\nimport time\n\n\ndef prepare_ice_cream(flavor):\n    print(f\"Preparing {flavor} ice cream...\")\n    time.sleep(2)  # Simulate time-consuming preparation\n    print(f\"{flavor} ice cream is ready!\")\n\n\n# Usage\nprocesses = []\nfor flavor in [\"Vanilla\", \"Chocolate\", \"Strawberry\"]:\n    process = multiprocessing.Process(target=prepare_ice_cream, args=(flavor,))\n    processes.append(process)\n    process.start()\n\nfor process in processes:\n    process.join()\n\n```\n\nAsyncio: Understanding the Asynchronous Programming Model\nAsyncio is a Python library that provides a framework for writing single-threaded concurrent code using coroutines, multiplexing I/O access over sockets and other resources, running network clients and servers, and other related primitives.\n\nIce Cream Order Asyncio Example:\n```python\nimport asyncio\n\nasync def serve_ice_cream(flavor):\n    print(f\"Start serving {flavor} ice cream...\")\n    await asyncio.sleep(2)  # Simulate time-consuming serving\n    print(f\"{flavor} ice cream served!\")\n\n# Usage\nasync def main():\n    tasks = [serve_ice_cream(flavor) for flavor in [\"Vanilla\", \"Chocolate\", \"Strawberry\"]]\n    await asyncio.gather(*tasks)\n\nasyncio.run(main())\n```\n\nIn this section on Concurrency and Parallelism, we explored threading and multiprocessing for running code in parallel, making your application more responsive and faster. We also delved into asyncio, a powerful library for writing asynchronous code, which is particularly useful for IO-bound and high-level structured network code. By understanding and utilizing these concepts, you can significantly enhance the performance and responsiveness of your ice cream store application, especially under high demand or complex operational scenarios.\n\n",
    "supporting": [
      "post_files"
    ],
    "filters": [],
    "includes": {}
  }
}