[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "My Articles",
    "section": "",
    "text": "Beyond the Basics: Patterns for Aspiring Python Developers\n\n\n\n\n\n\n\nPython\n\n\nProgramming Patterns\n\n\n\n\nLearn about data classes, abstract methods, decorators, and much more\n\n\n\n\n\n\nJan 24, 2024\n\n\n\n\n\n\n  \n\n\n\n\nHow We Built Ask Priya\n\n\n\n\n\n\n\nLLMs\n\n\nRAG\n\n\n\n\nA Gen AI U.S. Immigration Assistant\n\n\n\n\n\n\nJan 24, 2024\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Filing taxes should be simple, especially for the 100M+ Americans who have the simple scenario of just one income source. UncleSamTax solves this by making filing taxes as simple as 1-2-3. How? We ask the user to upload the past year‚Äôs forms. We then use GPT-Vision to read the info from the forms and use GPT-4 to calculate values for the next year‚Äôs tax return form. And Voila! The user has a filled and prepared tax form that they submit to the government (aka UncleSam). By making doing taxes automated and simple, we are different from other complicated tax products (for every complicated tax scenario) as we are simple taxes for simple scenarios.\nUncle Sam Tax was built using Python, GPT-4, GPT-Vision, Trulens, Portkey, Streamlit etc. Uncle Sam Tax, as a proof of concept, won first place at the GPT hackathon in San Francisco. Our team then decided to go ahead and impelment it for the GPT-4 Powered App Creation Hackathon."
  },
  {
    "objectID": "projects.html#ask-priya",
    "href": "projects.html#ask-priya",
    "title": "Projects",
    "section": "Ask Priya",
    "text": "Ask Priya\n\nAsk Priya is an LLM RAG chatbot that answers questions about US immigration using Google‚Äôs chat bison model that is fed both the user question and retrieved immigration documents from a vector store. The vector store is built using Llama-index and the documents are scraped webpages from the USCIS website.\nAsk Priya performs way better than Ask Emma, the existing solution used by USCIS. Ask Priya also won first place in the Truera Gen AI hackathon.\nBuilt using Python, Llama-index, VertexAI, OpenAI, Trulens, Streamlit etc."
  },
  {
    "objectID": "projects.html#gemini-hire",
    "href": "projects.html#gemini-hire",
    "title": "Projects",
    "section": "Gemini Hire",
    "text": "Gemini Hire\n\nGemini Hire makes applying to jobs way easier using Gen AI. It parses your resume more effectively than Workday using Google‚Äôs gemini vision pro into a json file. That json file, along with a user pasted job description, is then fed into 3 sub applications - a cover letter generator, interview questions generator and a skills gap analysis generator. These sub applications are mainly driven by Gemini Pro‚Äôs text model. Evaluation is done using Trulens and OpenAI‚Äôs API. GeminiHire won second place at the Gemini AI Hackathon!\nBuilt using Python, Gemini Vision Pro, OpenAI, Trulens, HuggingFace, Gradio etc."
  },
  {
    "objectID": "projects.html#data-science-new-tab-chrome-application",
    "href": "projects.html#data-science-new-tab-chrome-application",
    "title": "Projects",
    "section": "Data Science New Tab Chrome Application",
    "text": "Data Science New Tab Chrome Application\n\nNew Tab application for Chrome with quick access to University of San Francisco pages like MyUSF, calendar, one card etc. Additionally keep up with recent papers and blogs in AI and latest events in San Francisco (updated daily). Also has a to-do list.\nBuilt using Python, React, Firebase, TailwindCSS, Chrome storage API etc."
  },
  {
    "objectID": "posts/python_masterclass/post.html#in-this-section-we-delved-deeper-into-the-object-oriented-features-of-python-by-exploring-mixins-for-composition-metaclasses-for-dynamic-class-creation-and-the-conventions-around-private-and-protected-members.-each-of-these-topics-presents-sophisticated-ways-to-structure-your-python-code-for-maximum-readability-maintainability-and-functionality-especially-in-complex-applications-like-managing-an-ice-cream-stores-operations.",
    "href": "posts/python_masterclass/post.html#in-this-section-we-delved-deeper-into-the-object-oriented-features-of-python-by-exploring-mixins-for-composition-metaclasses-for-dynamic-class-creation-and-the-conventions-around-private-and-protected-members.-each-of-these-topics-presents-sophisticated-ways-to-structure-your-python-code-for-maximum-readability-maintainability-and-functionality-especially-in-complex-applications-like-managing-an-ice-cream-stores-operations.",
    "title": "Beyond the Basics: Patterns for Aspiring Python Developers",
    "section": "In this section, we delved deeper into the object-oriented features of Python by exploring mixins for composition, metaclasses for dynamic class creation, and the conventions around private and protected members. Each of these topics presents sophisticated ways to structure your Python code for maximum readability, maintainability, and functionality, especially in complex applications like managing an ice cream store‚Äôs operations.",
    "text": "In this section, we delved deeper into the object-oriented features of Python by exploring mixins for composition, metaclasses for dynamic class creation, and the conventions around private and protected members. Each of these topics presents sophisticated ways to structure your Python code for maximum readability, maintainability, and functionality, especially in complex applications like managing an ice cream store‚Äôs operations.\nPython Function Essentials Function Signatures: Crafting Readable and Maintainable Interfaces Function signatures are the part of the function that defines its input and output. A clear and concise function signature can significantly improve the readability and maintainability of your code. Python‚Äôs type hinting and default values are some tools you can use to create such signatures.\nIce Cream Order Function Example:\n\nfrom typing import List\n\ndef place_order(flavor: str, scoops: int = 1, toppings: List[str] = None) -&gt; None:\n    toppings_list = toppings if toppings else [\"No toppings\"]\n    print(f\"Order: {scoops} scoop(s) of {flavor} ice cream with {' and '.join(toppings_list)}.\")\n\nplace_order(\"Vanilla\", 2, [\"Cherry\", \"Sprinkles\"])\nplace_order(\"Chocolate\") # Uses default scoops and toppings\n\nOrder: 2 scoop(s) of Vanilla ice cream with Cherry and Sprinkles.\nOrder: 1 scoop(s) of Chocolate ice cream with No toppings.\n\n\nArguments: Understanding *args and **kwargs *args and **kwargs allow you to pass a variable number of arguments to a function, which can be very helpful when you don‚Äôt know beforehand how many arguments you will need. *args is used to send a non-keyworded variable-length argument list, and **kwargs allows you to pass keyworded variable length of arguments.\nCustom Ice Cream Mix Function Example:\n\ndef mix_ice_cream(*flavors, **toppings):\n    print(f\"Mixing {' and '.join(flavors)}.\")\n    if toppings:\n        print(\"Adding toppings:\")\n        for topping, quantity in toppings.items():\n            print(f\"- {quantity}x {topping}\")\n\nmix_ice_cream(\"Vanilla\", \"Strawberry\", Sprinkles=10, Nuts=5)\n\nMixing Vanilla and Strawberry.\nAdding toppings:\n- 10x Sprinkles\n- 5x Nuts\n\n\nAbstract Base Classes and Protocols Abstract Base Classes (ABCs) and protocols are used to define a set of methods that must be created within any child classes built from the abstract class or implementing the protocol. They are a form of interface checking more strict than duck-typing and allow for a cleaner architecture.\nIce Cream Machine Interface Example:\n\nfrom abc import ABC, abstractmethod\n\nclass IceCreamMachine(ABC):\n    @abstractmethod\n    def make_ice_cream(self, flavor: str) -&gt; None:\n        pass\n\nclass SoftServeMachine(IceCreamMachine):\n    def make_ice_cream(self, flavor: str) -&gt; None:\n        print(f\"Dispensing soft serve {flavor} ice cream.\")\n\nmachine = SoftServeMachine()\nmachine.make_ice_cream(\"Mango\")\n\nDispensing soft serve Mango ice cream.\n\n\nIn this section, we explored how to define clear and effective functions in Python. By designing intuitive function signatures, utilizing variable arguments, and adhering to the principles of abstract base classes and protocols, you can write code that is both flexible and easy to understand. These practices are crucial for creating a robust and maintainable codebase, especially in complex applications such as those for managing an ice cream store.\nUsage of collections.abc like Iterable The collections.abc module provides a set of abstract base classes that can be used to test whether a class provides a particular interface, for example, whether it is iterable. This can be particularly useful when you want to enforce that an object adheres to a certain protocol or interface.\nIce Cream Batch Iterable Example:\n\nfrom collections.abc import Iterable\n\nclass IceCreamBatch:\n    def __init__(self, flavors):\n        self.flavors = flavors\n\n    def __iter__(self):\n        return iter(self.flavors)\n\nbatch = IceCreamBatch([\"Vanilla\", \"Chocolate\", \"Strawberry\"])\nfor flavor in batch:\n    print(f\"Flavor: {flavor}\")\n\nFlavor: Vanilla\nFlavor: Chocolate\nFlavor: Strawberry\n\n\nDefining Custom Abstract Methods Custom abstract methods can be defined in your classes to enforce that certain methods are implemented in subclasses, providing a clear contract for subclass implementation.\nCustom Ice Cream Maker Example:\n\nfrom abc import ABC, abstractmethod\n\nclass CustomIceCreamMaker(ABC):\n    @abstractmethod\n    def make_ice_cream(self, flavor: str, toppings: list):\n        pass\n\nclass GourmetIceCreamMaker(CustomIceCreamMaker):\n    def make_ice_cream(self, flavor: str, toppings: list):\n        print(f\"Creating gourmet {flavor} ice cream with {', '.join(toppings)}.\")\n\ngourmet_maker = GourmetIceCreamMaker()\ngourmet_maker.make_ice_cream(\"Mint Chocolate\", [\"Chocolate Chips\", \"Mint Leaves\"])\n\nCreating gourmet Mint Chocolate ice cream with Chocolate Chips, Mint Leaves.\n\n\nLambda Functions: When and How to Use Them Effectively Lambda functions are small anonymous functions that are defined with the lambda keyword. They can have any number of arguments but only one expression. They are handy for creating quick functions that aren‚Äôt complex.\nFavorite Flavor Filter Example:\n\nflavors = [\"Vanilla\", \"Chocolate\", \"Strawberry\", \"Mint\"]\n\n# Filter flavors list to only include flavors that contain the letter 'n'\nfiltered_flavors = list(filter(lambda flavor: 'n' in flavor, flavors))\nprint(filtered_flavors)  # Output: ['Vanilla', 'Mint']\n\n['Vanilla', 'Mint']\n\n\nClosures and Factory Functions: Encapsulating State and Behavior Closures are a way of keeping alive a function with its environment. A closure is a record storing a function together with an environment: a mapping associating each free variable of the function with the value or storage location to which the name was bound when the closure was created.\nIce Cream Customizer Factory Example:\n\ndef ice_cream_customizer(topping):\n    def add_topping(flavor):\n        return f\"{flavor} ice cream with {topping}\"\n    return add_topping\n\nadd_chocolate_syrup = ice_cream_customizer(\"Chocolate Syrup\")\nprint(add_chocolate_syrup(\"Vanilla\")) # Output: Vanilla ice cream with Chocolate Syrup\n\nVanilla ice cream with Chocolate Syrup\n\n\nIn this expanded section, we dove deeper into abstract base classes with collections.abc and defining custom abstract methods, giving you the tools to enforce class interfaces in a structured way. We also explored lambda functions for quick, one-off functional operations and closures for maintaining state in your functions, all of which enhance the flexibility and expressiveness of your Python code in managing an ice cream store‚Äôs operations.\n\nHere‚Äôs the content for Section 4: Error Handling and Logging, formatted for easy copy-pasting into your .qmd file:\nError Handling and Logging Raising Exceptions: Structured Way of Using raise In Python, exceptions are raised whenever a program encounters an error. The raise statement allows you to force a specified exception to occur. Properly handling these exceptions is crucial for maintaining the reliability and robustness of your applications.\nIce Cream Flavor Availability Check Example:\n\ndef check_flavor_availability(flavor, available_flavors):\n    if flavor not in available_flavors:\n        raise ValueError(f\"{flavor} is not available.\")\n    print(f\"{flavor} is available!\")\n\ntry:\n    check_flavor_availability(\"Pistachio\", [\"Vanilla\", \"Chocolate\", \"Strawberry\"])\nexcept ValueError as e:\n    print(e)\n\nPistachio is not available.\n\n\nCommon Exception Types: TypeError, AssertionError, NotImplementedError, etc. Python comes with a variety of built-in exceptions, which are classes that can be used to communicate what type of error occurred. Understanding these can help you better diagnose problems and inform users more effectively.\nIce Cream Serving Size Example:\n\ndef serve_ice_cream(scoops):\n    if not isinstance(scoops, int):\n        raise TypeError(\"Scoops must be an integer.\")\n    if scoops &lt;= 0:\n        raise ValueError(\"Scoops must be a positive number.\")\n    if scoops &gt; 3:\n        raise AssertionError(\"Too many scoops requested!\")\n    print(f\"Serving {scoops} scoops of ice cream!\")\n\ntry:\n    serve_ice_cream(4)\nexcept (TypeError, ValueError, AssertionError) as e:\n    print(e)\n\nToo many scoops requested!\n\n\nIn this section, we explored the structured way of raising exceptions in Python and handling common exception types. Through effective error handling and understanding of Python‚Äôs exception hierarchy, you can make your ice cream store application more reliable and user-friendly, avoiding unexpected crashes and providing clear feedback for troubleshooting.\nLogging: Leveraging Python‚Äôs Logging Module for Scalable Applications Python‚Äôs built-in logging module allows you to track events when your application runs, providing a flexible way to output informational and error messages. Logging is essential for debugging and understanding the behavior of an application, especially as it grows in complexity.\nIce Cream Store Logging Example:\n\nimport logging\n\nlogging.basicConfig(level=logging.INFO)\n\ndef restock_ice_cream(flavor, quantity):\n    logging.info(f\"Restocking {flavor}: {quantity} units.\")\n    # Restocking logic here\n    if quantity &lt; 0:\n        logging.error(\"Quantity cannot be negative!\")\n\nrestock_ice_cream(\"Vanilla\", 20)\nrestock_ice_cream(\"Chocolate\", -5) # Triggers error log\n\nCustom Exceptions: Designing for Clarity and Control Custom exceptions allow you to create your own exception types, making your code‚Äôs error messages more informative and easier to understand. This can be particularly helpful in debugging or when other developers are using your code.\nCustom InsufficientStockException Example:\n\nclass InsufficientStockException(Exception):\n    def __init__(self, flavor, requested, available):\n        message = f\"{flavor} stock insufficient. Requested: {requested}, Available: {available}\"\n        super().__init__(message)\n\ndef sell_ice_cream(flavor, quantity, stock):\n    if stock[flavor] &lt; quantity:\n        raise InsufficientStockException(flavor, quantity, stock[flavor])\n    stock[flavor] -= quantity\n    print(f\"Selling {quantity} {flavor} ice creams!\")\n\nstock = {\"Vanilla\": 10, \"Chocolate\": 5}\ntry:\n    sell_ice_cream(\"Vanilla\", 15, stock)\nexcept InsufficientStockException as e:\n    print(e)\n\nVanilla stock insufficient. Requested: 15, Available: 10\n\n\nContextual Logging: Enhancing Logs with Contextual Information Contextual logging involves adding additional information to your logs, such as timestamps, function names, or other relevant data. This makes the logs more useful and easier to understand, especially when dealing with complex systems or when you‚Äôre trying to debug issues post-mortem.\nEnhanced Ice Cream Store Logging Example:\n\nimport logging\n\nlogger = logging.getLogger(\"IceCreamLogger\")\nhandler = logging.StreamHandler()\nformatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\nhandler.setFormatter(formatter)\nlogger.addHandler(handler)\nlogger.setLevel(logging.INFO)\n\ndef make_ice_cream(flavor):\n    logger.info(f\"Making {flavor} ice cream.\")\n    # Ice cream making logic here\n    if flavor == \"Mint\":\n        logger.warning(\"Mint is currently low in stock!\")\n\nmake_ice_cream(\"Vanilla\")\nmake_ice_cream(\"Mint\") # Triggers a warning log\n\nIn this expanded section of Error Handling and Logging, we delved into the world of logging, custom exceptions, and contextual logging in Python. By implementing these techniques, you can greatly improve the maintainability, debuggability, and overall quality of your applications, making it easier to manage your ice cream store‚Äôs operations and quickly respond to issues as they arise.\n\nNaming and Documentation Conventions Naming Conventions: Understanding Underscore Prefixes and Dunder Methods Python uses underscores as a way of indicating the intended privacy level and role of variables, methods, and functions. Single and double underscores have special meanings, and understanding these conventions can make your code more Pythonic and readable.\nUnderscore and Dunder Example in Ice Cream Context:\n\nclass IceCream:\n    def __init__(self, flavor):\n        self.flavor = flavor  # Public attribute\n        self._temperature = -5  # Protected attribute: intended for internal use\n        self.__secret_recipe = \"Sugar and Spice\"  # Private attribute: name mangling\n\n    def get_secret_recipe(self):\n        return self.__secret_recipe  # Accessing the private attribute internally\n\nice_cream = IceCream(\"Vanilla\")\nprint(ice_cream.flavor)  # Public, so accessible\nprint(ice_cream._temperature)  # Protected, should not be accessed directly\n# Trying to access the private attribute directly will raise an AttributeError due to name mangling\n# Correct way is to use a method that accesses it internally like get_secret_recipe()\ntry:\n    print(ice_cream.__secret_recipe)\nexcept AttributeError as e:\n    print(\"Can't access private attribute:\", e)\n\nVanilla\n-5\nCan't access private attribute: 'IceCream' object has no attribute '__secret_recipe'\n\n\nDocumentation Standards: Best Practices for Writing Python Docstrings Docstrings are a way of documenting Python modules, functions, classes, and methods. They‚Äôre essential for making your code understandable to others and your future self. Well-written docstrings can also facilitate automatic documentation generation.\nDocstring Example for Ice Cream Class:\n\nclass IceCream:\n    \"\"\"\n    A class representing an ice cream with various properties.\n    Attributes:\n        flavor (str): The flavor of the ice cream.\n        scoops (int): The number of scoops.\n    \"\"\"\n\n    def __init__(self, flavor, scoops=1):\n        \"\"\"\n        The constructor for IceCream class.\n\n        Parameters:\n            flavor (str): The flavor of the ice cream.\n            scoops (int): The number of scoops. Default is 1.\n        \"\"\"\n        self.flavor = flavor\n        self.scoops = scoops\n\nPEP 8 and Beyond: Exploring Python Enhancement Proposals Related to Style and Convention PEP 8 is the de facto code style guide for Python. It‚Äôs important to adhere to these guidelines to ensure that your code is clean, readable, and consistent with what the majority of Python developers expect.\nIce Cream Store Code Style Example:\n\ndef restock_ice_cream(flavor, quantity):\n    if quantity &gt; 0:\n        print(f\"Restocking {quantity} units of {flavor} ice cream.\")\n    else:\n        print(\"Cannot restock negative quantity!\")\nrestock_ice_cream(\"Chocolate\", 20)\n\nRestocking 20 units of Chocolate ice cream.\n\n\nType Docstrings: Documenting Types and Expected Behaviors Type docstrings are an extension of regular docstrings that include information about the types of parameters, return values, and exceptions. They can greatly enhance the understandability of your code, especially when used in conjunction with static type checkers.\nType Docstring for Ice Cream Factory Function:\n\ndef create_ice_cream(flavor: str, toppings: list) -&gt; \"IceCream\":\n    \"\"\"\n    Creates an IceCream object with the given flavor and toppings.\n    Parameters:\n        flavor (str): The flavor of the ice cream.\n        toppings (list): A list of toppings to add.\n\n    Returns:\n        IceCream: An IceCream object with specified flavor and toppings.\n\n    Raises:\n        ValueError: If no flavor is provided.\n    \"\"\"\n    if not flavor:\n        raise ValueError(\"Flavor is required!\")\n    return IceCream(flavor, toppings)\n\nIn this section, we explored the essential naming and documentation conventions in Python. By adhering to these conventions and utilizing docstrings effectively, you can make your code much more understandable and maintainable. This is especially crucial in collaborative environments or when your codebase grows in size and complexity. Each of these practices plays a vital role in keeping your ice cream store‚Äôs codebase healthy and robust.\n\nHere‚Äôs the content for the first part of Section 6: Performance and Efficiency Patterns, focusing on deep vs shallow copies, and enums and constants, formatted for easy copy-pasting into your .qmd file:\nPerformance and Efficiency Patterns Deep vs Shallow Copies: Understanding .copy() and Its Implications In Python, copying objects is not always as straightforward as it might seem. A shallow copy creates a new object, but doesn‚Äôt create copies of the objects found within the original object. In contrast, a deep copy creates a new object and recursively copies all the objects found within the original object. Understanding the difference is crucial for managing memory and avoiding unintended side effects, especially when working with complex, mutable data structures.\nShallow vs Deep Copy Example:\n\nimport copy\n\n# Original list of ice cream flavors\noriginal_flavors = [[\"Vanilla\", \"Chocolate\"], [\"Strawberry\"]]\n\n# Shallow copy: only copies the outer list\nshallow_copied_flavors = copy.copy(original_flavors)\nshallow_copied_flavors[0][0] = \"Mint\"\nprint(original_flavors) # Notice \"Mint\" replaces \"Vanilla\" in the original\n\n# Deep copy: copies all levels\ndeep_copied_flavors = copy.deepcopy(original_flavors)\ndeep_copied_flavors[1][0] = \"Blueberry\"\nprint(original_flavors) # The original remains unchanged\n\n[['Mint', 'Chocolate'], ['Strawberry']]\n[['Mint', 'Chocolate'], ['Strawberry']]\n\n\nEnums and Constants: Utilizing enum for Readable and Efficient Code Enums (enumerations) are sets of symbolic names bound to unique, constant values. In Python, enums are implemented using the enum module. Using enums can make your code more readable and maintainable by providing meaningful names to constant values.\nIce Cream Flavor Enums Example:\n\nfrom enum import Enum\n\nclass IceCreamFlavor(Enum):\n    VANILLA = 1\n    CHOCOLATE = 2\n    STRAWBERRY = 3\n    MINT = 4\n\ndef serve(flavor: IceCreamFlavor):\n    if flavor == IceCreamFlavor.MINT:\n        print(\"Serving Mint Flavor!\")\n    else:\n        print(f\"Serving {flavor.name} Flavor!\")\n\n# Usage\nserve(IceCreamFlavor.MINT)  # Outputs: Serving Mint Flavor!\nserve(IceCreamFlavor.VANILLA)  # Outputs: Serving VANILLA Flavor!\n\nServing Mint Flavor!\nServing VANILLA Flavor!\n\n\nIn this section, we covered two important aspects of performance and efficiency patterns in Python: understanding the implications of shallow and deep copies, and utilizing enums for cleaner, more efficient code. These practices can help prevent bugs and improve the performance of your applications, contributing to a well-functioning ice cream store‚Äôs operations.\nUsing auto and unique for Custom Enumerations The auto feature in Python‚Äôs enum module can automatically assign values to members, making it easier to manage enums. The unique decorator ensures all values are distinct, preventing duplicate values that can lead to bugs.\nCustom Ice Cream Size Enumeration Example:\n\nfrom enum import Enum, auto, unique\n\n@unique\nclass IceCreamSize(Enum):\n    SMALL = auto()\n    MEDIUM = auto()\n    LARGE = auto()\n\ndef order(size: IceCreamSize):\n    print(f\"Ordering a {size.name} ice cream!\")\n\n# Usage\norder(IceCreamSize.SMALL)  # Outputs: Ordering a SMALL ice cream!\n\nOrdering a SMALL ice cream!\n\n\nIterators and Generators: Lazy Evaluation and Efficient Looping Iterators and generators provide a way to iterate over data more efficiently by lazy evaluating elements, meaning they generate items as needed. This can lead to performance improvements, particularly with large data sets.\nDaily Specials Generator Example:\n\ndef daily_specials(specials):\n    for special in specials:\n        yield f\"Today's special is: {special}\"\n\nspecials_generator = daily_specials([\"Vanilla\", \"Chocolate\", \"Strawberry\"])\nprint(next(specials_generator)) # Outputs: Today's special is: Vanilla\nprint(next(specials_generator)) # Outputs: Today's special is: Chocolate\n\nToday's special is: Vanilla\nToday's special is: Chocolate\n\n\nPython Caching Techniques: functools.lru_cache and Beyond Caching is a technique used to store previous computation results and reuse them when the same inputs occur again, improving the performance of applications. Python provides built-in decorators for caching, like functools.lru_cache, which implements a least recently used cache.\nCached Ice Cream Mix Function Example:\n\nfrom functools import lru_cache\n\n\n@lru_cache(maxsize=32)\ndef mix_ice_cream(flavor1, flavor2):\n    print(f\"Mixing {flavor1} and {flavor2}...\")\n    return f\"{flavor1} and {flavor2} mixed!\"\n\n\nprint(mix_ice_cream(\"Vanilla\", \"Chocolate\"))  # Function is executed\n# Result is cached and returned immediately\n# Result is cached and returned immediately\nprint(mix_ice_cream(\"Vanilla\", \"Chocolate\")) # Result is cached and returned immediately\n\nMixing Vanilla and Chocolate...\nVanilla and Chocolate mixed!\nVanilla and Chocolate mixed!\n\n\nIn this expanded section of Performance and Efficiency Patterns, we explored using auto and unique decorators for defining enums more effectively, leveraging iterators and generators for efficient data handling, and utilizing caching techniques to optimize performance. By incorporating these patterns, you can ensure that your ice cream store‚Äôs operations run smoothly, even as demand and complexity grow.\n\nAdvanced Python Patterns Dependency Injection: Techniques for Cleaner Architecture Dependency Injection (DI) is a design pattern that allows a program to remove hard-coded dependencies and makes it more modular, enabling easier testing and maintenance. In Python, DI can be done in various ways, such as through constructor injection, setter injection, or using a framework.\nIce Cream Machine Dependency Injection Example:\n\nclass IceCreamMaker:\n    def make_ice_cream(self, flavor):\n        print(f\"Making {flavor} ice cream.\")\n\nclass IceCreamStore:\n    def __init__(self, maker: IceCreamMaker):\n        self.maker = maker\n\n    def order_ice_cream(self, flavor):\n        self.maker.make_ice_cream(flavor)\n\nmaker = IceCreamMaker()\nstore = IceCreamStore(maker)\nstore.order_ice_cream(\"Vanilla\")  # Outputs: Making Vanilla ice cream.\n\nMaking Vanilla ice cream.\n\n\nPlugin Architecture: Building Extensible Python Applications Plugin architectures allow you to create applications that can be extended through plugins. This pattern is useful for adding features, modifying behaviors, and integrating with other systems without changing the core application code.\nIce Cream Flavors Plugin Example:\n\nclass IceCreamMaker:\n    def __init__(self):\n        self.plugins = {}\n\n    def register_plugin(self, flavor, func):\n        self.plugins[flavor] = func\n\n    def make_ice_cream(self, flavor):\n        if flavor in self.plugins:\n            self.plugins[flavor]()\n        else:\n            print(f\"No plugin for {flavor}!\")\n\nmaker = IceCreamMaker()\n\ndef make_vanilla_ice_cream():\n    print(\"Making Vanilla Ice Cream!\")\n\nmaker.register_plugin(\"Vanilla\", make_vanilla_ice_cream)\nmaker.make_ice_cream(\"Vanilla\")  # Outputs: Making Vanilla Ice Cream!\n\nMaking Vanilla Ice Cream!\n\n\nEvent Driven Programming: Using Callbacks and Hooks Event-driven programming is a paradigm in which the flow of the program is determined by events such as user actions, sensor outputs, or message passing. Python supports event-driven programming by using callbacks and hooks, allowing functions to react to events.\nIce Cream Store Event System Example:\n\nclass EventManager:\n    def __init__(self):\n        self.listeners = {}\n\n    def listen(self, event, function):\n        if event not in self.listeners:\n            self.listeners[event] = []\n        self.listeners[event].append(function)\n\n    def trigger(self, event, data):\n        if event in self.listeners:\n            for function in self.listeners[event]:\n                function(data)\n\nevent_manager = EventManager()\n\ndef on_new_order(order):\n    print(f\"New order for {order} ice cream!\")\n\nevent_manager.listen('new_order', on_new_order)\nevent_manager.trigger('new_order', \"Vanilla\")  # Outputs: New order for Vanilla ice cream!\n\nNew order for Vanilla ice cream!\n\n\nIn this section on Advanced Python Patterns, we delved into Dependency Injection for cleaner, more modular code architectures, Plugin Architecture for building flexible and extensible applications, and Event-Driven Programming to create responsive and interactive systems. By applying these advanced patterns, your ice cream store application can become more robust, adaptable, and scalable.\n\nHere‚Äôs the content for Section 8: Concurrency and Parallelism, focusing on threading and multiprocessing, and asyncio, formatted for easy copy-pasting into your .qmd file:\nConcurrency and Parallelism Threading and Multiprocessing: When and How to Use Them Python offers several ways to achieve concurrency and parallelism. Two of the most common are threading and multiprocessing. Threading allows multiple threads to run in the same memory space, while multiprocessing involves running separate memory spaces and is often used to bypass Python‚Äôs Global Interpreter Lock (GIL).\nIce Cream Store Threading Example:\n\nimport threading\nimport time\n\n\ndef prepare_ice_cream(flavor):\n    print(f\"Preparing {flavor} ice cream...\")\n    time.sleep(2)  # Simulate time-consuming preparation\n    print(f\"{flavor} ice cream is ready!\")\n\n\nthreads = []\nfor flavor in [\"Vanilla\", \"Chocolate\", \"Strawberry\"]:\n    thread = threading.Thread(target=prepare_ice_cream, args=(flavor,))\n    threads.append(thread)\n    thread.start()\n\nfor thread in threads:\n    thread.join()\n\nPreparing Vanilla ice cream...\nPreparing Chocolate ice cream...\nPreparing Strawberry ice cream...\nVanilla ice cream is ready!Chocolate ice cream is ready!\nStrawberry ice cream is ready!\n\n\n\nIce Cream Store Multiprocessing Example:\n\nimport multiprocessing\nimport time\n\n\ndef prepare_ice_cream(flavor):\n    print(f\"Preparing {flavor} ice cream...\")\n    time.sleep(2)  # Simulate time-consuming preparation\n    print(f\"{flavor} ice cream is ready!\")\n\n\n# Usage\nprocesses = []\nfor flavor in [\"Vanilla\", \"Chocolate\", \"Strawberry\"]:\n    process = multiprocessing.Process(target=prepare_ice_cream, args=(flavor,))\n    processes.append(process)\n    process.start()\n\nfor process in processes:\n    process.join()\nAsyncio: Understanding the Asynchronous Programming Model Asyncio is a Python library that provides a framework for writing single-threaded concurrent code using coroutines, multiplexing I/O access over sockets and other resources, running network clients and servers, and other related primitives.\nIce Cream Order Asyncio Example:\nimport asyncio\n\nasync def serve_ice_cream(flavor):\n    print(f\"Start serving {flavor} ice cream...\")\n    await asyncio.sleep(2)  # Simulate time-consuming serving\n    print(f\"{flavor} ice cream served!\")\n\n# Usage\nasync def main():\n    tasks = [serve_ice_cream(flavor) for flavor in [\"Vanilla\", \"Chocolate\", \"Strawberry\"]]\n    await asyncio.gather(*tasks)\n\nasyncio.run(main())\nIn this section on Concurrency and Parallelism, we explored threading and multiprocessing for running code in parallel, making your application more responsive and faster. We also delved into asyncio, a powerful library for writing asynchronous code, which is particularly useful for IO-bound and high-level structured network code. By understanding and utilizing these concepts, you can significantly enhance the performance and responsiveness of your ice cream store application, especially under high demand or complex operational scenarios."
  },
  {
    "objectID": "posts/ask_priya_v1/post.html",
    "href": "posts/ask_priya_v1/post.html",
    "title": "How We Built Ask Priya",
    "section": "",
    "text": "US Immigration is complicated\nThere are millions of people looking to either visit, move to or reside in the US. And in that pursuit, they are confronted with the US immigration system overseen by the USCIS (United States Citizenship and Immigration Services).\nAnd as anyone will tell you, dealing with the USCIS is a nightmare. The forms are complicated, the instructions are confusing and the wait times are long. And if you make a mistake, you could be denied entry or worse, deported.\nThe abundance of policies, forms and instructions are overwhelming, especially for native English speakers.\n\n\nThe current solution\nUSCIS‚Äôs attempt at a solution is ‚ÄòAsk Emma‚Äô which, in their words, is a ‚Äúcomputer-generated virtual assistant who can answer your questions and even take you to the right spot on our website.‚Äù\nBut Ask Emma is not very helpful. It is not very smart and it is not very human. It‚Äôs responses are quite formulaic, with users typically picking from a menu of choices. Here you can see Ask Emma not knowing an answer to a question that is very common among international students.\n\nFurthermore, Ask Emma is not very accessible as it is only available in English and Spanish.\n\n\nThe better solution - Ask Priya\nSo you have this large body of textual information on immigration services that is publicly available on the USCIS website, and a poorly perofrming chatbot that is not very accessible. How do we make this information more accessible?\nEnter Retrieval Augmented Generation (RAG) models. RAG models are a combination of a retrieval model and a generation model. The retrieval model is used to retrieve relevant passages from the USCIS website, and the generation model is used to generate an answer to the question based on the retrieved passages and the user‚Äôs question.\nSo a few compadres and I built Ask Priya.\n\n\n\nSystems design\nSo how does Ask Priya work under the hood? At a high level, it takes a user‚Äôs question, embeds it using openai‚Äôs ada-002 model, then similar documents are retrieved from the llama-index vector store, and then the LLM, Vertex AI Chat Bison, is given both the question and the retrieved documents to generate an answer, which is then returned to the user. The vector store here contains embeddings of all the documents (web pages) on the USCIS website.\nAnd this pipeline‚Äôs performance is evaluated using Trulens Eval which I will cover in detail in the next section.\n\n\n\nEvaluation\nSo we have a working RAG model, but how do we know if it is performing well? To answer that, we first needed a baseline performance for comparison.\nSo we used the trulens package to establish an ‚Äòanswer relevance‚Äô score for Ask Emma. For the unacquainted, trulens is a package that essentially lets you easily use LLMs to evaluate LLM performance. It works by prompting another LLM, known as an ‚Äòevaluator,‚Äô to assess the performance of your model. This assessment typically involves scoring the original model‚Äôs responses based on criteria such as ‚Äòanswer relevance,‚Äô which measures how closely the LLM‚Äôs response aligns with the user‚Äôs query.\nThe difference in answer relevance between Ask Emma (0.33) and Ask Priya (0.99) is quite stark. This means that Ask Priya‚Äôs is actually answering the question asked by the user. Of course, this is not indicative of whether the answer is actually correct, but it is a great start.\n\n\n\nNext steps\nThe proof of concept for Ask Priya won first place at the Truera Hackathon and we are excited to continue working on it. Some of the next steps include:\n\nTry further advanced retrieval strategies to improve the groundedness metric\nFurther prompt engineering to improve answer quality\nMigrate to google cloud deployment\nAdd more trulens feedback functions\n\nAnd more! Excited for the progression of Ask Priya!"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Hi, I‚Äôm Bassim üëãüèæ",
    "section": "",
    "text": "class AboutBassim: \n    def __init__(self):\n        self.occupation = 'Machine Learning Engineer'\n        self.skills = (\n            'Python',\n            'Machine Learning',\n            'A/B testing',\n            'Generative AI'\n        )\n        self.hobbies = (\n            'üèãÔ∏è‚Äç‚ôÇÔ∏è Powerlifting',\n            'üå∂Ô∏è Eating spicy food',\n            'üèì Playing pickleball'\n        )\n        self.current_favorite_music_artists = (\n            'Takeshi's Cashew',\n            'Etran de L`A√Ør',\n            'French79'\n        )\n        self.fun_fact = 'I grew up in Dubai!'"
  },
  {
    "objectID": "posts/python_masterclass/post.html#inheritance",
    "href": "posts/python_masterclass/post.html#inheritance",
    "title": "Beyond the Basics: Patterns for Aspiring Python Developers",
    "section": "Inheritance",
    "text": "Inheritance\nInheritance allows new objects to take on the properties of existing objects. It‚Äôs a way to form new classes using classes that have already been defined.\nIce Cream and Sorbet Example:\n\nclass IceCream:\n    def __init__(self, flavor):\n        self.flavor = flavor\n\nclass Sorbet(IceCream):  # Sorbet is a type of Ice Cream\n    def __init__(self, flavor, fruit_content):\n        super().__init__(flavor)\n        self.fruit_content = fruit_content\n\n# Usage\nlemon_sorbet = Sorbet(\"Lemon\", 30)\nprint(lemon_sorbet.flavor) \n\nLemon\n\n\nDecorators in Depth Decorators are a significant part of Python. In simple words, decorators modify the behavior of function or class. In terms of the ice cream store, think of a decorator as an additional topping or feature to your basic ice cream functionality.\nStatic Method and Property Example:\n\nclass IceCreamShop:\n    _sales_tax = 0.05  # 5% Sales Tax\n\n    @staticmethod\n    def compute_tax(amount):\n        return amount * IceCreamShop._sales_tax\n\n    @property\n    def sales_tax(self):\n        return self._sales_tax\n\n# Usage\nprint(IceCreamShop.compute_tax(100))  # Output: 5.0\nshop = IceCreamShop()\nprint(shop.sales_tax)  # Output: 0.05\n\n5.0\n0.05\n\n\nIn this section, we looked at how Python‚Äôs object-oriented programming features can be used to model real-world scenarios such as managing an ice cream store. Special methods allow us to integrate with Python‚Äôs built-in features and make our classes more intuitive. Inheritance lets us reuse and extend existing code, and decorators provide a flexible way to add or modify behavior without changing the existing code structure. All of these features are essential tools in a Python programmer‚Äôs toolkit.\nMixins: Leveraging for Composition Over Inheritance Mixins are a sort of class that is used to ‚Äúmix in‚Äù extra properties and methods into a class. This allows for an organized way of using composition to add features to classes in a modular and maintainable way. Unlike traditional inheritance, mixins don‚Äôt represent a ‚Äúis-a‚Äù relationship but rather a ‚Äúhas-a‚Äù relationship.\nIce Cream Mixin Example:\n\nclass FlavorMixin:\n    def add_flavor(self, flavor):\n        self.flavor = flavor\n        print(f\"Flavor {flavor} added!\")\n\nclass ToppingMixin:\n    def add_topping(self, topping):\n        self.topping = topping\n        print(f\"Topping {topping} added!\")\n\n# Base class\nclass BasicIceCream:\n    pass\n\n# Enhanced class with mixins\nclass DeluxeIceCream(FlavorMixin, ToppingMixin, BasicIceCream):\n    pass\n\n# Usage\ndeluxe = DeluxeIceCream()\ndeluxe.add_flavor(\"Chocolate\")\ndeluxe.add_topping(\"Sprinkles\")\n\nFlavor Chocolate added!\nTopping Sprinkles added!\n\n\nMeta-Classes: Understanding Dynamic Class Creation Metaclasses are the ‚Äòclasses of classes‚Äô in Python. They define the behavior of a class and its instances. They are an advanced feature that allows you to control the creation of classes and can be used to provide elegant solutions to complex problems.\nIce Cream Meta-Class Example:\n\nclass MetaIceCream(type):\n    def __new__(cls, name, bases, dct):\n        dct['favorite_flavor'] = \"vanilla\"  # let's say vanilla is the favorite flavor by default\n        return super().__new__(cls, name, bases, dct)\n\nclass IceCream(metaclass=MetaIceCream):\n    def __init__(self, flavor):\n        self.flavor = flavor\n\n# Usage\nic = IceCream(\"strawberry\")\nprint(ic.favorite_flavor)  # Even though it's not defined explicitly, it's vanilla\n\nvanilla\n\n\nPrivate and Protected Members: Conventions and Enforcement In Python, there is a convention for indicating that a variable is intended to be private or protected using underscores. A single underscore _ before a variable name is conventionally used for protected members, and a double underscore __ for private members. This doesn‚Äôt enforce strict privacy or protection but is a strong indication to other programmers, and also influences name mangling to avoid naming conflicts in subclasses.\nPrivate and Protected Members Example:\n\nclass IceCreamMachine:\n    def __init__(self, model):\n        self._operating_temp = -10  # Protected Member\n        self.__model = model  # Private Member\n\n    def dispense(self):\n        print(f\"Dispensing at {self._operating_temp} degrees from {self.__model}.\")\n\n# Usage\nmachine = IceCreamMachine(\"Frosty 5000\")\nmachine.dispense()\nprint(machine._operating_temp)  # This is accessible but shouldn't be altered directly\n# print(machine.__model)  # This will give an error as it's a private member\n\nDispensing at -10 degrees from Frosty 5000.\n-10"
  },
  {
    "objectID": "projects.html#jobocomplete",
    "href": "projects.html#jobocomplete",
    "title": "Projects",
    "section": "JoboComplete",
    "text": "JoboComplete\n\nManually inputting the same information like name, email, LinkedIn URL etc. over and over again for each application is a dreadful experience. JoboComplete, a Chrome extension, that automates input filling using LlamaIndex‚Äôs RAG capabilities, which has information about your resume.\nBuilt using Javascript, Python, FastAPI, LlamaIndex etc. JoboComplete won Honorable Mention at the LlamaIndex RAG hackathon!"
  },
  {
    "objectID": "projects.html#ab-agent",
    "href": "projects.html#ab-agent",
    "title": "Projects",
    "section": "AB Agent",
    "text": "AB Agent\n\nAB Agent automates two parts of the A/B testing workflow using Generative AI:\nDesign\nThe design phase of A/B testing is crucial for setting the stage for meaningful insights. AB Agent simplifies this process in three steps:\n\nUnderstanding User Instructions: Initially, AB Agent takes a user‚Äôs natural language instruction to set up an experiment. For example, a user might say, ‚ÄúDesign an A/B test to test a UI change where the metric to increase is browsing time. We want the minimum effect to be 10% and we want to be 95% confident in the results.‚Äù\nRephrasing Queries: The instruction is then passed through the mixtral-8x7b-instruct model, which rephrases the user query into a more statistically oriented format. This step ensures that the setup is aligned with statistical best practices and clarifies the experiment‚Äôs objectives.\nFunction Calling for Experiment Design: Subsequently, the refined query is passed to firefunction-v1. This component ideally calls a sample size calculator among other tools to determine the necessary sample size and other critical details for designing the A/B test effectively.\n\nInference\nThe inference phase is where the results of the A/B test are interpreted to make informed decisions:\n\nInterpreting Results: For interpreting the outcomes of an A/B test, AB Agent employs a function-calling model that uses a t-test calculator and other functions. This approach facilitates a robust analysis of the results.\nMaking Decisions: Based on this analysis, AB Agent makes a go/no-go decision on whether to implement feature B. This decision-making process is backed by statistical evidence, ensuring that changes are made with confidence in their impact.\n\nBuilt using Python, React, Fireworks etc. AB Agent was a finalist project at the OSS Functional Calling Hackathon."
  },
  {
    "objectID": "projects.html#design",
    "href": "projects.html#design",
    "title": "Projects",
    "section": "Design",
    "text": "Design\nThe design phase of A/B testing is crucial for setting the stage for meaningful insights. AB Agent simplifies this process in three steps:\n\nUnderstanding User Instructions: Initially, AB Agent takes a user‚Äôs natural language instruction to set up an experiment. For example, a user might say, ‚ÄúDesign an A/B test to test a UI change where the metric to increase is browsing time. We want the minimum effect to be 10% and we want to be 95% confident in the results.‚Äù\nRephrasing Queries: The instruction is then passed through the mixtral-8x7b-instruct model, which rephrases the user query into a more statistically oriented format. This step ensures that the setup is aligned with statistical best practices and clarifies the experiment‚Äôs objectives.\nFunction Calling for Experiment Design: Subsequently, the refined query is passed to firefunction-v1. This component ideally calls a sample size calculator among other tools to determine the necessary sample size and other critical details for designing the A/B test effectively."
  },
  {
    "objectID": "projects.html#inference",
    "href": "projects.html#inference",
    "title": "Projects",
    "section": "Inference",
    "text": "Inference\nThe inference phase is where the results of the A/B test are interpreted to make informed decisions:\n\nInterpreting Results: For interpreting the outcomes of an A/B test, AB Agent employs a function-calling model that uses a t-test calculator and other functions. This approach facilitates a robust analysis of the results.\nMaking Decisions: Based on this analysis, AB Agent makes a go/no-go decision on whether to implement feature B. This decision-making process is backed by statistical evidence, ensuring that changes are made with confidence in their impact.\n\nBuilt using Python, React, Fireworks etc. AB Agent was a finalist project at the OSS Functional Calling Hackathon."
  },
  {
    "objectID": "projects.html#uncle-sam-tax",
    "href": "projects.html#uncle-sam-tax",
    "title": "Projects",
    "section": "",
    "text": "Filing taxes should be simple, especially for the 100M+ Americans who have the simple scenario of just one income source. UncleSamTax solves this by making filing taxes as simple as 1-2-3. How? We ask the user to upload the past year‚Äôs forms. We then use GPT-Vision to read the info from the forms and use GPT-4 to calculate values for the next year‚Äôs tax return form. And Voila! The user has a filled and prepared tax form that they submit to the government (aka UncleSam). By making doing taxes automated and simple, we are different from other complicated tax products (for every complicated tax scenario) as we are simple taxes for simple scenarios.\nUncle Sam Tax was built using Python, GPT-4, GPT-Vision, Trulens, Portkey, Streamlit etc. Uncle Sam Tax, as a proof of concept, won first place at the GPT hackathon in San Francisco. Our team then decided to go ahead and impelment it for the GPT-4 Powered App Creation Hackathon."
  }
]